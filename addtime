#!/bin/bash

# read times from stdin and add them up.
#

# defaults
delimiter=:

# how to exit on error
errexit() {
  echo $@
  exit 1
}

# check for missing dependencies
for dependency in cat getopt tr; do
  command -v $dependency >/dev/null || errexit "Dependency $dependency not found."
done
unset dependency

# usage/help
# contains literal tabs in here-doc
usage() {
  cat <<-EOF
	Add a list of times from standard input using day:hour:minute:second format.
	All fields but seconds are optional. Field separator is ':' by default. One
	measurement of time per line.

	Usage: ${0##*/} [-d|--delimiter] [-h|--help]
	Options:
	  -d, --delimiter DELIM
	    Use DELIM instead of : for field delimiter
	  -h, --help
	    This message
	EOF
}

# get options
opts=$(getopt -o d:,h -l delimiter:,help -n ${0##*/} -- "$@")
[[ $? == 0 ]] || errexit "Could not get command line options."

# parse options
eval set -- "$opts"
while [[ $1 != '--' ]]; do
  case $1 in
    -d|--delimiter)
      delimiter="$2"
      shift 2
      ;;
    -h|--help|*)
      usage
      exit
      ;;
  esac
done

# make sure delimiter is only one character
[[ ${#delimiter} != 1 ]] && errexit "Delimiter must be one character."

# declare array total
declare -A total=([seconds]=0 [minutes]=0 [hours]=0 [days]=0)

# while consuming input
while read time; do

# pad input with $delimiter for some reason
  time=${delimiter}${time}

  for unit in seconds minutes hours days; do
    if [[ $time != $delimiter && -n $time ]]; then
# add rightmost field to total[$unit]
# need to force base 10 because of leading 0s
      total[$unit]=$((10#${total[$unit]} + 10#${time##*$delimiter}))

# strip ${delimiter}${time##*$delimiter} from right of string
      time=${time%${delimiter}${time##*$delimiter}}
    fi
  done
  unset unit

# if string is not empty after processing 4 fields, print error and exit 1
  if [[ -n $time ]]; then
    errexit "Input seems to contain too many fields. Please limit to seconds, hours, minutes, days."
  fi

done

# whole groups of 60 (seconds/60) get added to minutes
total[minutes]=$((${total[minutes]} + (${total[seconds]} / 60)))

# seconds are the remainder of seconds/60
total[seconds]=$((${total[seconds]} % 60))

# zero fill seconds if <= 9
if [[ ${total[seconds]} -le 9 ]]; then
  total[seconds]=0${total[seconds]}
fi

# whole groups of 60 (minutes/60) get added to hours
total[hours]=$((${total[hours]} + (${total[minutes]} / 60)))

# minutes are the remainder of minutes/60
total[minutes]=$((${total[minutes]} % 60))

# zero fill minutes if <= 9
if [[ ${total[minutes]} -le 9 ]]; then
  total[minutes]=0${total[minutes]}
fi

# whole groups of 24 (hours/24) get added to days
total[days]=$((${total[days]} + (${total[hours]} / 24)))

# hours are the remainder of hours/24
total[hours]=$((${total[hours]} % 24))

# zero fill hours if <= 9
if [[ ${total[hours]} -le 9 ]]; then
  total[hours]=0${total[hours]}
fi

# print ${total[days]} ${total[hours]}  ${total[minutes]} ${total[seconds]}
echo Total time: ${total[days]}:${total[hours]}:${total[minutes]}:${total[seconds]}
